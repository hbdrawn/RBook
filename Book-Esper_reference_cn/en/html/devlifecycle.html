<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 16. Development Lifecycle</title><link rel="stylesheet" href="css/espertech.css" type="text/css"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL-NS Stylesheets V1.74.0"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" http-equiv="Content-Type" content="text/html; charset=UTF-8"/><link rel="home" href="index.html" title="Esper Reference"/><link rel="up" href="index.html" title="Esper Reference"/><link rel="prev" href="configuration.html" title="Chapter 15. Configuration"/><link rel="next" href="extension.html" title="Chapter 17. Integration and Extension"/></head><body><p xmlns:d="http://docbook.org/ns/docbook" id="title"><a href="http://www.espertech.com" class="site_href"><strong>esper.codehaus.org and espertech.com</strong></a><a href="http://esper.codehaus.org/esper/documentation/documentation.html" class="doc_href"><strong>Documentation</strong></a></p><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="configuration.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="extension.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="devlifecycle"/>Chapter 16. Development Lifecycle</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="devlifecycle.html#devlifecycle-authoring">16.1. Authoring</a></span></dt><dt><span class="sect1"><a href="devlifecycle.html#devlifecycle-testing">16.2. Testing</a></span></dt><dt><span class="sect1"><a href="devlifecycle.html#devlifecycle-debugging">16.3. Debugging</a></span></dt><dd><dl><dt><span class="sect2"><a href="devlifecycle.html#devlifecycle-debugging-audit">16.3.1. @Audit Annotation</a></span></dt></dl></dd><dt><span class="sect1"><a href="devlifecycle.html#devlifecycle-packagedeploy">16.4. Packaging and Deploying Overview</a></span></dt><dt><span class="sect1"><a href="devlifecycle.html#devlifecycle-eplmodule">16.5. EPL Modules</a></span></dt><dt><span class="sect1"><a href="devlifecycle.html#devlifecycle-admin">16.6. The Deployment Administrative Interface</a></span></dt><dd><dl><dt><span class="sect2"><a href="devlifecycle.html#devlifecycle-admin-readparse">16.6.1. Reading Module Content</a></span></dt><dt><span class="sect2"><a href="devlifecycle.html#devlifecycle-admin-order">16.6.2. Ordering Multiple Modules</a></span></dt><dt><span class="sect2"><a href="devlifecycle.html#devlifecycle-admin-devlifecycle-undeploy">16.6.3. Deploying and Undeploying</a></span></dt><dt><span class="sect2"><a href="devlifecycle.html#devlifecycle-admin-list">16.6.4. Listing Deployments</a></span></dt><dt><span class="sect2"><a href="devlifecycle.html#devlifecycle-admin-transition">16.6.5. State Transitioning a Module</a></span></dt><dt><span class="sect2"><a href="devlifecycle.html#devlifecycle-admin-bestpractices">16.6.6. Best Practices</a></span></dt></dl></dd><dt><span class="sect1"><a href="devlifecycle.html#devlifecycle-j2ee">16.7. J2EE Packaging and Deployment</a></span></dt><dd><dl><dt><span class="sect2"><a href="devlifecycle.html#devlifecycle-j2ee-considerations">16.7.1. J2EE Deployment Considerations</a></span></dt><dt><span class="sect2"><a href="devlifecycle.html#devlifecycle-j2ee-servletcontextlistener">16.7.2. Servlet Context Listener</a></span></dt></dl></dd></dl></div><p>
		This chapter presents information related to the development lifecycle for developing an event processing application with EPL. It includes information on authoring, testing, debugging, packaging and deploying.
    </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="devlifecycle-authoring"/>16.1. Authoring</h2></div></div></div><p>
          Enterprise Edition includes authoring tools for EPL statements and modules by providing form-based dialogs, templates, an expression builder, simulation tool and other tools. Enterprise Edition also supports hot deployment and packaging options for EPL and related code.
        </p><p>
           EPL statements can be organized into modules as described below. Any text editor can edit EPL statement and module text. A text editor or IDE that highlights SQL syntax or keywords works.
        </p><p>
			For authoring configuration files please consult the XSD schema files as provided with the distribution.
        </p><p>
            For information on authoring event classes or event definitions in general please see <a class="xref" href="event_representation.html" title="Chapter 2. Event Representations">Chapter 2, <i>Event Representations</i></a> or <a class="xref" href="epl_clauses.html#epl_createschema" title="5.16. Declaring an Event Type: Create Schema">Section 5.16, “Declaring an Event Type: Create Schema”</a>.
        </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="devlifecycle-testing"/>16.2. Testing</h2></div></div></div><p>
			We recommend testing EPL statements using a test framework such as JUnit or TestNG. Please consult the Esper test suite for extensive examples, which can be downloaded from the distribution site.
        </p><p>
           Esper's API provides test framework classes to simplify automated testing of EPL statements. Please see <a class="xref" href="api.html#api-testing" title="14.20. Test and Assertion Support">Section 14.20, “Test and Assertion Support”</a> for more information.
        </p><p>
			We recommend performing latency and throughput tests early in the development lifecycle. Please consider the performance tips in <a class="xref" href="performance.html" title="Chapter 20. Performance">Chapter 20, <i>Performance</i></a> for optimal performance.
        </p><p>
			Consider engine and statement metrics reporting for identifying slow-performing statements, for example. See <a class="xref" href="api.html#api-instrumentation" title="14.14. Engine and Statement Metrics Reporting">Section 14.14, “Engine and Statement Metrics Reporting”</a>.
        </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="devlifecycle-debugging"/>16.3. Debugging</h2></div></div></div><p>
            One important tool for debugging is the parameterized <code class="literal">@Audit </code> annotation. This annotation allows to output, on statement-level, detailed information about many aspects of statement processing.
        </p><p>
			Another tool for logging engine-level detail is <a class="xref" href="configuration.html#config-engine-logging-execpath" title="15.4.13.1. Execution Path Debug Logging">Section 15.4.13.1, “Execution Path Debug Logging”</a>.
        </p><p>
			Please see <a class="xref" href="configuration.html#configuration-logging" title="15.7. Logging Configuration">Section 15.7, “Logging Configuration”</a> for information on configuring logging in general.
        </p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="devlifecycle-debugging-audit"/>16.3.1. @Audit Annotation</h3></div></div></div><p>
				Use the <code class="literal">@Audit</code> annotation to have the engine output detailed information about statement processing. The engine reports, at INFO level, the information under log name <code class="literal">com.espertech.esper.audit</code>. You may define an output format for audit information via configuration.
			</p><p>
				You may provide a comma-separated list of category names to <code class="literal">@Audit</code> to output information related to specific categories only. The table below lists all available categories. If no parameter is provided, the engine outputs information for all categories. Category names are not case-sensitive.
			</p><p>
				For the next statement  the engine produces detailed processing information (all categories) for the statement: 
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Name('All Order Events') @Audit select * from OrderEvent</pre><p>
				For the next statement the engine provides information about new events and also about event property values (2 categories are listed):
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Name('All Order Events') @Audit('stream,property') select price from OrderEvent</pre><p>
				Here is a more complete example that uses the API to create the schema, create above statement and send an event:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">epService.getEPAdministrator().createEPL("create schema OrderEvent(price double)");
String epl = "@Name('All-Order-Events') @Audit('stream,property') select price from OrderEvent";
epService.getEPAdministrator().createEPL(epl).addListener(listener);
epService.getEPRuntime().sendEvent(Collections.singletonMap("price", 100d), "OrderEvent");</pre><p>
				The output is similar to the following:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">INFO  [audit] Statement All-Order-Events stream OrderEvent inserted {price=100.0}
INFO  [audit] Statement All-Order-Events property price value 100.0</pre><div class="table"><a id="d0e36605"/><p class="title"><b>Table 16.1. @Audit Categories</b></p><div class="table-contents"><table summary="@Audit Categories" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Category</th><th>Description</th></tr></thead><tbody><tr><td>Dataflow-Source</td><td>Each data flow source operator providing an event.</td></tr><tr><td>Dataflow-Op</td><td>Each data flow operator processing an event.</td></tr><tr><td>Dataflow-Transition</td><td>Each data flow instance state transition.</td></tr><tr><td>Exprdef</td><td>Each expression declaration name and return value.</td></tr><tr><td>Expression</td><td>Each top-level expression and its return value.</td></tr><tr><td>Expression-nested</td><td>Each expression including child or nested expressions and their return value.</td></tr><tr><td>Insert</td><td>Each event inserted via insert-into.</td></tr><tr><td>Pattern</td><td>Each pattern sub-expression and its change in truth-value.</td></tr><tr><td>Pattern-instances</td><td>Each pattern sub-expression and its count of active instances.</td></tr><tr><td>Property</td><td>Each property name and the event's property value.</td></tr><tr><td>Schedule</td><td>Each schedule modification and trigger received by a statement.</td></tr><tr><td>Stream</td><td>Each new event received by a statement.</td></tr><tr><td>View</td><td>Each view name and its insert and remove stream.</td></tr></tbody></table></div></div><br class="table-break"/><p>
				Note that the engine only evaluates select-clause expressions if either a listener or subscriber is attached to the statement or if used with insert-into.
			</p></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="devlifecycle-packagedeploy"/>16.4. Packaging and Deploying Overview</h2></div></div></div><p>
			Please consider Esper Enterprise Edition as a target deployment platform. Esper alone does not ship with a server as it is designed as a core CEP engine.
		</p><p>
			To support packaging and deploying event-driven applications, Esper offers infrastructure as outlined herein:
        </p><div class="itemizedlist"><ul><li><p>
                    EPL modules to build a cohesive, easily-externalizable deployment unit out of related statements as described in <a class="xref" href="devlifecycle.html#devlifecycle-eplmodule" title="16.5. EPL Modules">Section 16.5, “EPL Modules”</a>.
                </p></li><li><p>
                    The deployment administrative interface is described in <a class="xref" href="devlifecycle.html#devlifecycle-admin" title="16.6. The Deployment Administrative Interface">Section 16.6, “The Deployment Administrative Interface”</a>.
                </p></li><li><p>
			        Instructions and code for use when the deployment target is a J2EE web application server or servlet runtime, please see <a class="xref" href="devlifecycle.html#devlifecycle-j2ee" title="16.7. J2EE Packaging and Deployment">Section 16.7, “J2EE Packaging and Deployment”</a>.
                </p></li></ul></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="devlifecycle-eplmodule"/>16.5. EPL Modules</h2></div></div></div><a id="d0e36711" class="indexterm"/><a id="d0e36716" class="indexterm"/><p>
			An EPL module file is a plain text file in which EPL statements appear separated by the semicolon (;) character. It bundles EPL statements with optional deployment instructions. A service provider instance keeps track of the known and/or deployed EPL modules and makes it easy to add, remove, deploy and undeploy EPL modules.
		</p><p>
			The synopsis of an EPL module file is:
		</p><pre class="synopsis">[module <span class="emphasis"><em>module_name</em></span>;]
[uses <span class="emphasis"><em>module_name</em></span>; | import <span class="emphasis"><em>import_name</em></span>;] [uses <span class="emphasis"><em>module_name</em></span>; | import <span class="emphasis"><em>import_name</em></span>;] [...]
[<span class="emphasis"><em>epl_statement</em></span>;] [<span class="emphasis"><em>epl_statement</em></span>;] [...]</pre><p>
			Use the <code class="literal">module</code> keyword followed a <span class="emphasis"><em>module_name</em></span> identifier or a package (identifiers separated by dots) to declare the name of the module. The module name declaration must be at the beginning of the file, comments and whitespace excluded. The module name 
			serves to check uses-dependences of other modules.  
		 </p><p>
			If a module file requires certain constructs that may be shared by other module files, such as named windows, variables, event types, variant streams or inserted-into streams required by statements,
			a module file may specify zero to many dependent modules with the <code class="literal">uses</code> keyword. At deployment time the engine checks the uses-dependencies
			and ensures that a module of that name is already deployed or will be deployed as part of the deployments. The deployment API supports ordering modules according to their uses-relationship.
		 </p><p>
			 If the EPL statements in the module require Java classes such as for underlying events or user-defined functions, use the <code class="literal">import</code> keyword followed by the fully-qualified class name or package name in the format <code class="literal">package.*</code>.
			 The <code class="literal">uses</code> and <code class="literal">import</code> keywords are optional and must occur after the <code class="literal">module</code> declaration.
		 </p><p>
			 Following the optional deployment instructions are any number of <span class="emphasis"><em>epl_statement</em></span> EPL statements that are separated by semicolon (<code class="literal">;</code>).
		 </p><p>
			 The following is a sample EPL module file explained in detail thereafter:
		 </p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">// Declare the name for the module
module org.myorganization.switchmonitor;

// Declare other module(s) that this module depends on
uses org.myorganization.common;

// Import any Java/.NET classes in an application package 
import org.myorganization.events.*;

// Declare an event type based on a Java class in the package that was imported as above
create schema MySwitchEvent as MySwitchEventPOJO;

// Sample statement
@Name('Off-On-Detector')
insert into MyOffOnStream
select * from pattern[every-distinct(id) a=MySwitchEvent(status='off') 
  -&gt; b=MySwitchEvent(id=a.id, status='on')];

// Sample statement
@Name('Count-Switched-On')
@Description('Count per switch id of the number of Off-to-On switches in the last 1 hour')
select id, count(*) from MyOffOnStream.win:time(1 hour) group by id;</pre><p>
			The example above declares a module name of <code class="literal">org.myorganization.switchmonitor</code>. As defined by the <code class="literal">uses</code> keyword, it ensures that the <code class="literal">org.myorganization.common</code> module is already deployed.
			The example demonstrates the <code class="literal">import</code> keyword to make a package name known to the engine for resolving POJO class names, as the example assumes that <code class="literal">MySwitchEventPOJO</code> is a POJO event class.
			In addition the example module contains two statements separated by semicolon characters.
        </p><p>
			Your application code may, after deployment, look up a statement and attach listeners as shown here:
        </p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">epService.getEPAdministrator().getStatement("Count-Switched-On").addListener(...);</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="devlifecycle-admin"/>16.6. The Deployment Administrative Interface</h2></div></div></div><a id="d0e36814" class="indexterm"/><a id="d0e36819" class="indexterm"/><p>
			The <code class="literal">com.espertech.esper.client.deploy.EPDeploymentAdmin</code> service available from the <code class="literal">EPAdministrator</code> interface by method <code class="literal">getDeploymentAdmin</code> provides the functionality available to manage packaging and deployment.
			Please consult the JavaDoc documentation for more information.
		</p><p>
		  The deployment API allows to read resources and parse text strings to obtain an object representation of the EPL module, the <code class="literal">Module</code>. A <code class="literal">Module</code> object can also be simply constructed.
		</p><p>
		  After your application obtains a <code class="literal">Module</code> instance it may either use <code class="literal">deploy</code> to deploy the module directly, starting all statements of the module. Alternatively your application
		  may add a module, making it known without starting statements for later deployment. In each case the module is assigned a deployment id, which acts as a unique primary key for all known modules. Your application may assign its own deployment id
		  or may have the engine generate a deployment id (two footprints for <code class="literal">add</code> and <code class="literal">deploy</code> methods).
		</p><p>
		  A module may be in two states: undeployed or deployed. When calling <code class="literal">add</code> to add a module, it starts life in the undeployed state. When calling <code class="literal">deploy</code> to deploy a module, it starts life in the deployed state. 
		  A module may be transitioned by providing the deployment id and by calling the <code class="literal">deploy</code> or <code class="literal">undeploy</code> methods.
		</p><p>
		  Your code can remove a module in undeployed state using the <code class="literal">remove</code> method or the <code class="literal">undeployRemove</code> method. If the module is in deployed state, use <code class="literal">undeployRemove</code> to undeploy and remove the module.
		</p><p>
		  The <code class="literal">DeploymentOptions</code> instance that can be passed to the <code class="literal">deploy</code> method when validating or deploying modules controls validation, fail-fast, rollback and the isolated service provider, if any, for the deployment.
		  Also use <code class="literal">DeploymentOptions</code> to set a user object per statement or to set a statement name per statement.
		</p><p>
		  We also provide additional sample code to read and deploy modules as part of the J2EE considerations below.
		</p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="devlifecycle-admin-readparse"/>16.6.1. Reading Module Content</h3></div></div></div><p>
				Read and parse module files via the <code class="literal">EPDeploymentAdmin</code> interface <code class="literal">read</code> and <code class="literal">parse</code> methods, which returns a <code class="literal">Module</code> instance to represent the module information. 
			</p><p>
				This code snippet demonstrates reading and parsing a module given a file name:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPDeploymentAdmin deployAdmin = epService.getEPAdministrator().getDeploymentAdmin();
Module module = deployAdmin.read(new File("switchmonitor.epl"));</pre><p>
				The service provides additional read and parse methods to read from a URL, classpath, input stream or string.
			</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="devlifecycle-admin-order"/>16.6.2. Ordering Multiple Modules</h3></div></div></div><p>
				Since modules may have inter-dependencies as discussed under the <code class="literal">uses</code> declaration,  the deployment interface provides the <code class="literal">getDeploymentOrder</code> method to order a collection of modules before deployment.
			</p><p>
				Assuming your application reads multiple modules into a <code class="literal">mymodules</code> module list, this code snippet orders the modules for deployment and validates dependency declarations for each module:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">List&lt;Module&gt; mymodules =  ... read modules...;  
DeploymentOrder order = deployAdmin.getDeploymentOrder(mymodules, new DeploymentOrderOptions());</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="devlifecycle-admin-devlifecycle-undeploy"/>16.6.3. Deploying and Undeploying</h3></div></div></div><p>
				The deployment interface returns a deployment id for each module made known by adding a module or by deploying a module. To undeploy the module your application must provide the deployment id. Your application can assign its own deployment id or obtain the module name
				from the <code class="literal">Module</code> and use that as the deployment id.
			</p><p>
				The <code class="literal">undeploy</code> operation removes all named windows, variables, event types or any other information associated to the statements within the module to be undeployed.
			</p><p>
				The next code snippet deploys modules, starting each modulle's EPL statements:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">for (Module mymodule : order.getOrdered()) {
  DeploymentResult deployResult = deployAdmin.deploy(mymodule, new DeploymentOptions());
}</pre><p>
				Undeploying a module destroys all started statements associated to the module.
			</p><p>
				To undeploy and at the same time remove the module from the list of known modules use the <code class="literal">undeployRemove</code> method and pass the deployment id:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">deployAdmin.undeployRemove(deployResult.getDeploymentId());</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="devlifecycle-admin-list"/>16.6.4. Listing Deployments</h3></div></div></div><p>
				The deployment interface returns all module information that allows your application to determine which modules are known and their current state. 
			</p><p>
				To obtain a list of all known modules or information for a specific module, the calls are:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">DeploymentInformation[] info = deployAdmin.getDeploymentInformation();
			
// Given a deployment id, return the deployment information
DeploymentInformation infoModule = deployAdmin.getDeploymen(deploymentId);</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="devlifecycle-admin-transition"/>16.6.5. State Transitioning a Module</h3></div></div></div><p>
				The following sample code adds a module, transitions the module to deployed, then undeploys and removes the module entirely;
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">// This sample uses the parse method to obtain a module
Module module = deployAdmin.parse("create schema MySchema (col1 int)";

// Make the module know; It now shows up in undeployed state
String moduleDeploymentId = deployAdmin.add(module);

// Start all statements, passing a null options object for default options
deployAdmin.deploy(moduleDeploymentId, null);

// Undeploy module, destroying all statements
deployAdmin.undeploy(moduleDeploymentId);

// Remove module; It will no longer be known
deployAdmin.remove(moduleDeploymentId);</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="devlifecycle-admin-bestpractices"/>16.6.6. Best Practices</h3></div></div></div><p>
				Use the <code class="literal">@Name</code> annotation to assign a name to each statement that your application would like to attach a listener or subscriber, or look up the statement for iteration or management by the administrative API.
			</p><p>
				Use the <code class="literal">create schema</code> syntax and the <code class="literal">import</code> keyword to define event types. When sharing event types, named windows or variables between modules use the <code class="literal">uses</code> keyword to 
				declare a separate module that holds the shared definitions.
			</p><p>
				To validate whether a set of statements is complete and can start without issues, set the following flags on a <code class="literal">DeploymentOptions</code> instance passed to the <code class="literal">deploy</code> method as the code snippet below shows:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">DeploymentOptions options = new DeploymentOptions();
options.setIsolatedServiceProvider("validation");	// we isolate any statements 
options.setValidateOnly(true);	// validate leaving no started statements
options.setFailFast(false); // do not fail on first error
epService.getEPAdministrator().getDeploymentAdmin()
  .deploy(module, options);</pre></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="devlifecycle-j2ee"/>16.7. J2EE Packaging and Deployment</h2></div></div></div><a id="d0e37010" class="indexterm"/><a id="d0e37015" class="indexterm"/><p>
			Esper can well be deployed as part of a J2EE web or enterprise application archive to a web application server. 
			When designing for deployment into a J2EE web application server, please consider the items discussed here.
		</p><p>
			We provide a sample servlet context listener in this section that uses the deployment API to deploy and undeploy modules as part of the servlet lifecycle. 
		</p><p>
			The distribution provides a message-driven bean (MDB) example that you may find useful.
		</p><p>
			Esper does not have a dependency on any J2EE or Servlet APIs to allow the engine to run in any environment or container.
		</p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="devlifecycle-j2ee-considerations"/>16.7.1. J2EE Deployment Considerations</h3></div></div></div><p>
			  As multiple web applications deployed to a J2EE web application server typically have a separate classloader per application, you should consider whether engine instances need to be shared between applications or can remain separate engine instances. Consider the <code class="literal">EPServiceProviderManager</code> a Singleton. 
			  When deploying multiple web applications, your J2EE container classloader may provide a separate instance of the Singleton <code class="literal">EPServiceProviderManager</code> to each web application resulting in multiple independent engine instances.
			</p><p>
			  To share <code class="literal">EPServiceProvider</code> instances between web applications, one approach is to add the Esper jar files to the system classpath. A second approach can be to have multiple web applications share the same servet context and have your application place the <code class="literal">EPServiceProvider</code> instance into a servlet context attribute for sharing. Architecturally you may also consider a single archived application (such as an message-driven bean) that all your web applications communicate to via the JMS broker provided by your application server or an external JMS broker. 
			</p><p> 
			  As per J2EE standards there are restrictions in regards to starting new threads in J2EE application code. Esper adheres to these restrictions: It allows to be driven entirely by external events. To remove all Esper threads, set the internal timer off and leave the advanced threading options turned off.
			  To provide timer events when the internal timer is turned off, you should check with your J2EE application container for support of the Java system timer or for support of batch or work loading to send timer events to an engine instance.
			</p><p> 
			  As per J2EE standards there are restrictions in regards to input and output by J2EE application code. Esper adheres to these restrictions: By itself it does not start socket listeners or performs any file IO.
			</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="devlifecycle-j2ee-servletcontextlistener"/>16.7.2. Servlet Context Listener</h3></div></div></div><p>
				When deploying a J2EE archive that contains EPL modules files we provide sample code to read and deploy EPL modules files packaged with the enterprise or web application archive when the servlet initializes. The sample undeploys EPL modules when the servlet context gets destroyed.
			</p><p>
				A sample <code class="literal">web.xml</code> configuration extract is:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;SampleServletListener&lt;/listener-class&gt;
  &lt;/listener&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;eplmodules&lt;/param-name&gt;
    &lt;param-value&gt;switchmonitor.epl&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;/web-app&gt;</pre><p>
				A servet listener that deploys EPL module files packaged into the archive on context initialization and that undeploys when the application server destroys the context is shown here:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">public class SampleServletListener implements ServletContextListener {

  private List&lt;String&gt; deploymentIds = new ArrayList&lt;String&gt;();
  
  public void contextInitialized(ServletContextEvent servletContextEvent) {
    try {
      EPServiceProvider epServiceProvider = EPServiceProviderManager.getDefaultProvider();
      String modulesList = servletContextEvent.getServletContext().getInitParameter("eplmodules");
      List&lt;Module&gt; modules = new ArrayList&lt;Module&gt;();
      if (modulesList != null) {
        String[] split = modulesList.split(",");
        for (int i = 0; i &lt; split.length; i++) {
          String resourceName = split[i].trim();
          if (resourceName.length() == 0) {
            continue;
          }
          String realPath = servletContextEvent.getServletContext().getRealPath(resourceName);
  		Module module = epServiceProvider.getEPAdministrator()
  		        .getDeploymentAdmin().read(new File(realPath));
          modules.add(module);
        }
      }
    
      // Determine deployment order
      DeploymentOrder order = epServiceProvider.getEPAdministrator()
                  .getDeploymentAdmin().getDeploymentOrder(modules, null);
  
      // Deploy
      for (Module module : order.getOrdered()) {
        DeploymentResult result = epServiceProvider.getEPAdministrator()
                  .getDeploymentAdmin().deploy(module, new DeploymentOptions());
        deploymentIds.add(result.getDeploymentId());
      }
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
  }
  
  public void contextDestroyed(ServletContextEvent servletContextEvent) {
    EPServiceProvider epServiceProvider = EPServiceProviderManager.getDefaultProvider();
    for (String deploymentId : deploymentIds) {
       epServiceProvider.getEPAdministrator().getDeploymentAdmin().undeployRemove(deploymentId);
    }
  }
}</pre></div></div></div><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="configuration.html"><strong>Prev</strong>Chapter 15. Configuration</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="extension.html"><strong>Next</strong>Chapter 17. Integration and Extension</a></li></ul></body></html>